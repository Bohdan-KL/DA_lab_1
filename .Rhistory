source("C:/Users/maksn/Desktop/Study/6 sem/Аналіз даних/Labs/airbnb_cleaning.R")
packages <- c(
'dplyr',
'tidyr',
'readr',
'rstudioapi',
'mice'
)
for(package in packages){
if(!require(package, character.only = TRUE)){
install.packages(package, dependencies = TRUE)
}
library(package, character.only = TRUE)
}
data_file_name <- 'train.csv'
csv_path <- paste(dirname(getSourceEditorContext()$path), data_file_name, sep = '/')
csv_path
# Get probabilities of encoding
guess_encoding(csv_path, n_max = 1000)
# Mostly UTF-8
# Read dataframe
df = read.csv(csv_path)
# Get size of dataframe
init_shape <- dim(df)
# Remove unnecessary columns.
df <- df[
,!names(df) %in% c(
"thumbnail_url", "id", "description",
"name", 'first_review', 'host_since',
'last_review', 'neighbourhood', 'amenities',
'description', 'zipcode'
)
]
# Replace empty cells with NA
df[df == ''] <- NA
df$host_response_rate <- as.numeric(sub("%", "", df$host_response_rate)) / 100
df$host_has_profile_pic <- gsub("t", "True", df$host_has_profile_pic)
df$host_has_profile_pic <- gsub("f", "False", df$host_has_profile_pic)
df$host_has_profile_pic <- as.logical(factor(
unlist(df$host_has_profile_pic),
levels = c("False", "True")
)
)
df$host_identity_verified <- gsub("t", "True", df$host_identity_verified)
df$host_identity_verified <- gsub("f", "False", df$host_identity_verified)
df$host_identity_verified <- as.logical(factor(
unlist(df$host_identity_verified),
levels = c("False", "True")
)
)
# Editing data types
df$id <- as.character(df$id)
# Count na values.
init_na_count <- sum(is.na(df))
init_na_count_df <- data.frame(
sapply(df, function(y) sum(length(which(is.na(y)))))
)
# Count cells with empty values.
init_empty_count <- sum(df == "")
init_empty_count_df <- data.frame(
sapply(df, function(y) sum(length(which(y == ""))))
)
# Applying MICE package for filling missed data
df <- mice(df, printFlag = FALSE, seed=100)
df <- complete(df)
sum(df == "")
sum(is.na(df))
na_count <- sum(is.na(df))
na_count_df <- data.frame(
sapply(df, function(y) sum(length(which(is.na(y)))))
)
# Recount cells with empty values.
empty_count <- sum(df == "")
empty_count_df <- data.frame(
sapply(df, function(y) sum(length(which(y == ""))))
)
new_shape <- dim(df)
# Density plots
densityplot(df$bathrooms)
densityplot(df$host_has_profile_pic)
densityplot(df$host_identity_verified)
densityplot(df$host_response_rate)
densityplot(df$review_scores_rating)
densityplot(df$bedrooms)
densityplot(df$beds)
n <- dim(df)
2) 1 квартиль, медіана, 3 квартиль, коефіцієнти кореляції Пірсона і Спірмена
# Розмір вибірки
n <- dim(df)[0]
2) 1 квартиль, медіана, 3 квартиль, коефіцієнти кореляції Пірсона і Спірмена
# Розмір вибірки
n <- dim(df)(0)
2) 1 квартиль, медіана, 3 квартиль, коефіцієнти кореляції Пірсона і Спірмена
# Розмір вибірки
n <- dim(df)[0]
n
2) 1 квартиль, медіана, 3 квартиль, коефіцієнти кореляції Пірсона і Спірмена
# Розмір вибірки
n <- nrow(df)
n
# Довірчий інтервал для середнього значення ціни
price_mean <- mean(df$log_price)
price_mean
price_sd <- sd(df$log_price)
price_sd
price_confidence_interval <- t.test(df$log_price)$conf.int
price_confidence_interval
margin <- qt(0.95, df=n-1) * price_sd / sqrt(n)
low <- price_mean - margin
high <- price_mean + margin
low
high
price_confidence_interval <-
t.test(df$log_price, conf.level = confidence_level)$conf.int
# Довірчий рівень
confidence_level = 0.95
price_confidence_interval <-
t.test(df$log_price, conf.level = confidence_level)$conf.int
price_confidence_interval
price_confidence_interval[0]
price_confidence_interval[1]
price_confidence_interval[2]
price_confidence_interval
# Довірчий інтервал для дисперсії ціни
price_var_confidence_interval <-
var.test(df$log_price, conf.level = confidence_level)$conf.int
# Довірчий інтервал для дисперсії ціни
price_var_confidence_interval <-
var.test(df$log_price, conf.level = confidence_level)$conf.int
packages <- c(
'ggplot2',
'DescTools'
)
for(package in packages){
if(!require(package, character.only = TRUE)){
install.packages(package, dependencies = TRUE)
}
library(package, character.only = TRUE)
}
MeanCI(df$log_price, conf.level = confidence_level)
VarCI(df$log_price, conf.level = confidence_level)
# Довірчий інтервал для середнього значення ціни
price_mean_confidence_interval <-
MeanCI(df$log_price, conf.level = confidence_level)
# Довірчий інтервал для дисперсії ціни
price_var_confidence_interval <-
VarCI(df$log_price, conf.level = confidence_level)
packages <- c(
'dplyr',
'tidyr',
'readr',
'rstudioapi',
'mice'
)
for(package in packages){
if(!require(package, character.only = TRUE)){
install.packages(package, dependencies = TRUE)
}
library(package, character.only = TRUE)
}
data_file_name <- 'train.csv'
csv_path <- paste(dirname(getSourceEditorContext()$path), data_file_name, sep = '/')
csv_path
# Get probabilities of encoding
guess_encoding(csv_path, n_max = 1000)
# Mostly UTF-8
# Read dataframe
df = read.csv(csv_path)
# Get size of dataframe
init_shape <- dim(df)
# Remove unnecessary columns.
df <- df[
,!names(df) %in% c(
"thumbnail_url", "id", "description",
"name", 'first_review', 'host_since',
'last_review', 'neighbourhood', 'amenities',
'description', 'zipcode'
)
]
# Replace empty cells with NA
df[df == ''] <- NA
df$host_response_rate <- as.numeric(sub("%", "", df$host_response_rate)) / 100
df$host_has_profile_pic <- gsub("t", "True", df$host_has_profile_pic)
df$host_has_profile_pic <- gsub("f", "False", df$host_has_profile_pic)
df$host_has_profile_pic <- as.logical(factor(
unlist(df$host_has_profile_pic),
levels = c("False", "True")
)
)
df$host_identity_verified <- gsub("t", "True", df$host_identity_verified)
df$host_identity_verified <- gsub("f", "False", df$host_identity_verified)
df$host_identity_verified <- as.logical(factor(
unlist(df$host_identity_verified),
levels = c("False", "True")
)
)
# Editing data types
df$id <- as.character(df$id)
# Count na values.
init_na_count <- sum(is.na(df))
init_na_count_df <- data.frame(
sapply(df, function(y) sum(length(which(is.na(y)))))
)
# Count cells with empty values.
init_empty_count <- sum(df == "")
init_empty_count_df <- data.frame(
sapply(df, function(y) sum(length(which(y == ""))))
)
# Applying MICE package for filling missed data
df <- mice(df, printFlag = FALSE, seed=100)
df <- complete(df)
sum(df == "")
sum(is.na(df))
na_count <- sum(is.na(df))
na_count_df <- data.frame(
sapply(df, function(y) sum(length(which(is.na(y)))))
)
# Recount cells with empty values.
empty_count <- sum(df == "")
empty_count_df <- data.frame(
sapply(df, function(y) sum(length(which(y == ""))))
)
new_shape <- dim(df)
# Density plots
# densityplot(df$bathrooms)
# densityplot(df$host_has_profile_pic)
# densityplot(df$host_identity_verified)
# densityplot(df$host_response_rate)
# densityplot(df$review_scores_rating)
# densityplot(df$bedrooms)
# densityplot(df$beds)
packages <- c(
'ggplot2',
'DescTools'
)
for(package in packages){
if(!require(package, character.only = TRUE)){
install.packages(package, dependencies = TRUE)
}
library(package, character.only = TRUE)
}
# --- Довірчі інтервали ---
# Дослідницькі питання:
#   Чи залежить ціна від типу оселі?
#   Чи залежить рейтинг від наявності верифікації/фото?
#   Чи залежить ціна апартаментів від географічного положення?
#   Чи залежить рейтинг від типу орендованих кімнат?
#   Чи залежить ціна від рейтингу?
#
# Довірчі інтервали:
#   1) Для середнього і дисперсії
#   2) 1 квартиль, медіана, 3 квартиль, коефіцієнти кореляції Пірсона і Спірмена
# Розмір вибірки
n <- nrow(df)
# Рівень значущості
p <- 0.05
# Довірчий рівень
confidence_level = 0.95
# Довірчий інтервал для середнього значення ціни
price_mean_confidence_interval <-
MeanCI(df$log_price, conf.level = confidence_level)
# Довірчий інтервал для дисперсії ціни
price_var_confidence_interval <-
VarCI(df$log_price, conf.level = confidence_level)
# --- Доведення гіпотез ---
# Гіпотези:
df$host_response_rate
df$review_scores_rating
# Довірчий інтервал для середнього значення рейтингу
rating_mean_confidence_interval <-
MeanCI(df$review_scores_rating, conf.level = confidence_level)
# Довірчий інтервал для дисперсії рейтингу
rating_var_confidence_interval <-
VarCI(df$review_scores_rating, conf.level = confidence_level)
# Графік густини ціни
densityplot(df$log_price)
shapiro.test(df$log_price)
JarqueBeraTest(df$log_price)
JarqueBeraTest(df$review_scores_rating)
# Оскільки датасет великий, то оберемо метод Харке-Бера
# для дослідження на нормальність розподілу
JarqueBeraTest(df$log_price)
# Оскільки датасет великий, то оберемо метод Харке-Бера
# для дослідження на нормальність розподілу:
# Нормальність розподілу ціни:
JarqueBeraTest(df$log_price)
# Нормальність розподілу ціни:
JarqueBeraTest(df$log_price)
JarqueBeraTest(df$review_scores_rating)
JarqueBeraTest(df$review_scores_rating)
# Графік густини рейтингу
densityplot(df$review_scores_rating)
# Довірчий інтервал для середнього значення ціни
price_mean_confidence_interval <-
MeanCI(df$log_price, conf.level = confidence_level)
# Довірчий інтервал для дисперсії рейтингу
VarCI(df$review_scores_rating, conf.level = confidence_level)
# Довірчий інтервал для середнього значення ціни
MeanCI(df$log_price, conf.level = confidence_level)
# Довірчий інтервал для дисперсії ціни
VarCI(df$log_price, conf.level = confidence_level)
# Довірчий інтервал для середнього значення рейтингу
MeanCI(df$review_scores_rating, conf.level = confidence_level)
# Довірчий інтервал для дисперсії рейтингу
VarCI(df$review_scores_rating, conf.level = confidence_level)
View(df)
View(df)
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
df$property_type
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
unique(df$property_type)
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
unique(df$property_type)
MeanCI(
df[df$property_type == property_type]$log_price,
conf.level = confidence_level
)
MeanCI(
df[df$property_type == property_type_unit]$log_price,
conf.level = confidence_level
)
# MeanCI(
#   df[df$property_type == property_type_unit]$log_price,
#   conf.level = confidence_level
# )
}
for (i in 1:5) {
print(i)
}
print(property_type_unit)
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
property_type_unit <- ''
for(property_type_unit in unique(df$property_type)){
print(property_type_unit)
# MeanCI(
#   df[df$property_type == property_type_unit]$log_price,
#   conf.level = confidence_level
# )
}
MeanCI(
df[df$property_type == property_type_unit]$log_price,
conf.level = confidence_level
)
MeanCI(
df[df$property_type == property_type_unit]$log_price,
conf.level = confidence_level
)
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
property_type_unit <- "Apartment"
df[df$property_type == property_type_unit]
df[df$property_type == "Apartment"]
df[df$property_type == "Apartment"]
df[df$property_type == "Apartment",]
MeanCI(
df[df$property_type == property_type_unit, ]$log_price,
conf.level = confidence_level
)
print(property_type_unit)
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
for(property_type_unit in unique(df$property_type)){
print(property_type_unit)
MeanCI(
df[df$property_type == property_type_unit, ]$log_price,
conf.level = confidence_level
)
}
print(MeanCI(
df[df$property_type == property_type_unit, ]$log_price,
conf.level = confidence_level
)
)
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
for(property_type_unit in unique(df$property_type)){
print(property_type_unit)
print(MeanCI(
df[df$property_type == property_type_unit, ]$log_price,
conf.level = confidence_level
)
)
}
sum(is.na(df))
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
property_types <- unique(df$property_type)
for(property_type_unit in property_types){
print(property_type_unit)
print(MeanCI(
df[df$property_type == property_type_unit, ]$log_price,
conf.level = confidence_level
)
)
}
plot(property_types, df$log_price)
plot(property_types, property_types)
# Apartment
df[df$property_type == 'Apartment']
# Apartment
df[df$property_type == 'Apartment',]
# Apartment
df_apartment <- df[df$property_type == 'Apartment',]
min(df_apartment$log_price)
max(df_apartment$log_price)
cut(min(df_apartment$log_price):max(df_apartment$log_price), breaks = 5, include.lowest = TRUE)
max(df_apartment$log_price)
cutted <- cut(min(df_apartment$log_price):max(df_apartment$log_price), breaks = 5, include.lowest = TRUE)
cutted[1]
packages <- c(
'ggplot2',
'DescTools',
'pracma'
)
for(package in packages){
if(!require(package, character.only = TRUE)){
install.packages(package, dependencies = TRUE)
}
library(package, character.only = TRUE)
}
linspace(min(df_apartment$log_price), max(df_apartment$log_price), 5)
property_types <- unique(df$property_type)
length(property_types)
property_types <- unique(df$property_type)
price_splitted_y <-
linspace(
min(df_apartment$log_price),
max(df_apartment$log_price),
length(property_types)
)
price_splitted_y
plot(property_types, price_splitted_y)
property_types
# Дослідження довірчого інтервалу ціни в залежності від
# типу апартаментів:
ggplot(df, aes(property_type, log_price))
ggplot(df, aes(property_type, log_price))+
stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.1, size = 1) +
stat_summary(fun.y = mean, geom = "point", size = 6, shape = 22, fill = "white") +
theme_bw() +
xlab("Transmission type") +
ylab("Miles / (US) gallon")
ggplot(df, aes(property_type, log_price))+
stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.1, size = 1) +
stat_summary(fun.y = mean, geom = "point", size = 6, shape = 22, fill = "white") +
theme_bw() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
xlab("Property type") +
ylab("Price")
ggplot(df, aes(property_type, log_price))+
stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.1, size = 1) +
stat_summary(fun = mean, geom = "point", size = 6, shape = 22, fill = "white") +
theme_bw() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
xlab("Property type") +
ylab("Price")
ggplot(df, aes(room_type, log_price))+
stat_summary(fun.data = mean_cl_boot, geom = "errorbar", width = 0.1, size = 1) +
stat_summary(fun = mean, geom = "point", size = 6, shape = 22, fill = "white") +
theme_bw() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
xlab("Room type") +
ylab("Price")
